# Cosmetic

- Generate properly indented C code
- number strings, regexes, predicates and labels from their own counters
- Organize a bit, add subdirectories for regex/TDFA engine and optimizations
- Debugging: map IR labels to source labels

# Functionality/bugs

- Implement case conversions, \L\l\u\U - at least one is used by synsedizer
- Port IPC to compiler / RTS
- ConstPred pass is too slow, why?
- Improved correctness: use TNFA/TDFA simulator in Interpreter instead of
  regex-posix?
- implement `#n` (1.18), currently disabled in bsd.sh
- Ranges with 0 address (GNU extension). Very similar to 1,<> but allows the
  end address to match on the first line (or something).
  * Also apply appropriately to change-range special case...
  * And reconcile with the pre-first line feature

- Change and !:

  '8,9!chello': replaces *each* line with hello except line 8 and 9
  (are negated ranges even implemented?)

  a positive range such as 8,9chello replaces both lines with a single hello

- D/P (PrintFirstLine and DeleteFirstLine) are parsed but unimplemented?
  - tested by gnused's uniq.sed
  - now that pattern space is exposed to IR, we can use a regexp replace for it


# Testing

* Add some testing of regex matching, e.g. comparing regex-posix, TNFA and TDFA.
* Add tests for IPC functionality
* Add mode for bsd.sh that compares interpreted to compiled
  - Or just record known-good outputs for every test...
  - And move that into sedness

# Optimizations

## "Advanced"

* Use knowledge of regex to eliminate useless next-match calls
  - anchored at start: can't match again
  - anchored at end: first match will contain the end of the string
  - matches any suffix / ends with .*: first match will match all
* Track matched regexes until pattern space changes, check for equivalent
  regexes as well as impossible matches.
* Combine multiple regexes into a "switch" thing whenever there are multiple
  branches on matches.

## Operational

- Optimize out concatenation of empty strings
- Better way to handle concatentations without all the temporary strings

## Regex

* Finish minLength optimization:
  - Precalculate minLength and store in TDFA
* Strip out failed states
  1. Identify failed states using minLength
  2. Remove all transitions to failed states
  3. Remove failed states themselves (unless that happens automatically when
     they are not mentioned and have no transitions?)
* TNFA minimization - might make TDFA generation faster
* TDFA minimization - combine equivalent states
* More efficient searching:
  - Fancy: something with the start-of-match tag - "abandon" states where the
    start of match tag is already set but would be moved forward. Prototype in
    SimulateTNFA, then see if the logic can be ported to the TDFA construction?
  - Simpler: in cases where we don't emit tags at all the location/length of the
    match would not be relevant so we can exit with a match on the first final
    state and can look for e.g. ".*re".
* Add lower-level IR for TDFA output, to simplify code gen and enable Hoopling.

  All the stuff about fallback and EOF states should be emitted by TDFA -> IR,
  removing special cases in code generation. Maybe setting tags from registers
  and applying fixed tags is also done in the exit paths of the IR.

  - Should the retry loop be explicit here, or still done by the C codegen?
    Would be nice if it was explicit so that smart things about searching can
    be done without involving code gen.

### Done

* Return bool from match functions, remove `match_t::result`
* Track used groups in matches, feed back to regex compiler
* Skip retry if the regex is anchored at the start
* Parts of minLength optimization:
  - Split up state entry point to have one without range check
  - When transitioning to a state with a lower minLength, skip check

### Abandoned

* Port search with states as in SimulateTNFA to TDFA construction
  - Turns out this was wrong. Can it even work? Let's just do the other
    optimizations :)
